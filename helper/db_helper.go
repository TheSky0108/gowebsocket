package helper

import (
	"bytes"
	"context"
	"database/sql"
	"fmt"
	"github.com/spf13/viper"
	"log"
	//导入mysql的驱动
	_ "github.com/go-sql-driver/mysql"
)

/*
增删改查示例：

前提：建立连接 db := DbConnection()

增：
	insertStr := "insert into `user`(user_name,user_age,user_sex)values('littlecurl',18,'1')"
	DbExecSql(db, insertStr)
删：
	deleteStr := "delete from `user` where TimeCreated < @end and TimeCreated >= @start;`"
    sql.Named("start", startTime),
    sql.Named("end", endTime),


改：DbExecSql()
	updateStr := "update `user` set user_name='TOM' where user_id = 1"
	DbExecSql(db, updateStr)

查：DbQueryRow()
	var (
		user_name string
		user_age int
	)
	selectStr := "select user_name,user_age from user where user_id = 2"
	row := DbQueryRow(db,selectStr)
	row.Scan(&user_name,&user_age)
	fmt.Println(user_name,user_age)


事务隔离级别：
https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels
const (
    LevelDefault IsolationLevel = iota
    LevelReadUncommitted
    LevelReadCommitted
    LevelWriteCommitted
    LevelRepeatableRead
    LevelSnapshot
    LevelSerializable
    LevelLinearizable
)

数据库状态：
type DBStats struct {
    MaxOpenConnections int // Maximum number of open connections to the database; added in Go 1.11

    // Pool Status
    OpenConnections int // The number of established connections both in use and idle.
    InUse           int // The number of connections currently in use; added in Go 1.11
    Idle            int // The number of idle connections; added in Go 1.11

    // Counters
    WaitCount         int64         // The total number of connections waited for; added in Go 1.11
    WaitDuration      time.Duration // The total time blocked waiting for a new connection; added in Go 1.11
    MaxIdleClosed     int64         // The total number of connections closed due to SetMaxIdleConns; added in Go 1.11
    MaxLifetimeClosed int64         // The total number of connections closed due to SetConnMaxLifetime; added in Go 1.11
}

Result执行返回内容
type Result interface {
    // LastInsertId returns the integer generated by the database
    // in response to a command. Typically this will be from an
    // "auto increment" column when inserting a new row. Not all
    // databases support this feature, and the syntax of such
    // statements varies.
    LastInsertId() (int64, error)

    // RowsAffected returns the number of rows affected by an
    // update, insert, or delete. Not every database or database
    // driver may support this.
    RowsAffected() (int64, error)
}
*/
func main() {
	db := DbConnection()
	insertStr := "insert into `user`(user_name,user_age,user_sex)values('littlecurl',18,'1')"
	DbExecSql(db, insertStr)
}

func DbConnection() *sql.DB {
	var dataSourceName bytes.Buffer
	dataSourceName.WriteString(viper.GetString("mysql.dbUser"))
	dataSourceName.WriteString(viper.GetString("mysql.dbPassword"))
	dataSourceName.WriteString(viper.GetString("mysql.dbTcp"))
	dataSourceName.WriteString(viper.GetString("mysql.dbName"))
	dataSourceName.WriteString(viper.GetString("mysql.dbParameters"))

	db, err := sql.Open("mysql", dataSourceName.String())
	if err != nil {
		fmt.Println("连接数据库失败:", err)
		return nil
	}
	return db
}

/*
db.Exec() 用于执行单个语句
*/
func DbExecSql(db *sql.DB, sqlStr string) int64 {
	result, err := db.Exec(sqlStr)
	if err != nil {
		log.Println(err)
	}
	rows, err := result.RowsAffected()
	if err != nil {
		log.Println(err)
	}
	if rows != 1 {
		log.Println("expected to affect 1 row, affected %d", rows)
	}
	return rows
}

func DbExecSqlTx(ctx context.Context, db *sql.DB, sqlStr string) {
	tx, err := db.BeginTx(ctx, &sql.TxOptions{Isolation: sql.LevelSerializable})
	if err != nil {
		log.Println(err)
	}
	_, execErr := tx.ExecContext(ctx, sqlStr)
	if execErr != nil {
		if rollbackErr := tx.Rollback(); rollbackErr != nil {
			log.Println("update failed: %v, unable to rollback: %v\n", execErr, rollbackErr)
		}
		log.Println("update failed: %v", execErr)
	}
	if err := tx.Commit(); err != nil {
		log.Println(err)
	}
}

/*
db.Prepare() 预处理语句用于执行批处理语句
*/
func DbPrepareExecSql(db *sql.DB, sqlBatchStr string) {
	projects := []struct {
		mascot  string
		release int
	}{
		{"tux", 1991},
		{"duke", 1996},
		{"gopher", 2009},
		{"moby dock", 2013},
	}
	// sqlBatchStr = "INSERT INTO projects(mascot, release) VALUES( ?, ?)"
	stmt, err := db.Prepare(sqlBatchStr)
	if err != nil {
		log.Println(err)
	}
	defer stmt.Close() // Prepared statements take up server resources and should be closed after use.

	for id, project := range projects {
		if _, err := stmt.Exec(id+1, project.mascot, project.release, "open source"); err != nil {
			log.Println(err)
		}
	}
}

func DbPrepareExecSqlTx(db *sql.DB, sqlBatchStr string) {
	projects := []struct {
		mascot  string
		release int
	}{
		{"tux", 1991},
		{"duke", 1996},
		{"gopher", 2009},
		{"moby dock", 2013},
	}

	tx, err := db.Begin()
	if err != nil {
		log.Println(err)
	}
	defer tx.Rollback() // The rollback will be ignored if the tx has been committed later in the function.
	// sqlBatchStr = "INSERT INTO projects(id, mascot, release, category) VALUES( ?, ?, ?, ? )"
	stmt, err := tx.Prepare(sqlBatchStr)
	if err != nil {
		log.Println(err)
	}
	defer stmt.Close() // Prepared statements take up server resources and should be closed after use.

	for id, project := range projects {
		if _, err := stmt.Exec(id+1, project.mascot, project.release, "open source"); err != nil {
			log.Println(err)
		}
	}
	if err := tx.Commit(); err != nil {
		log.Println(err)
	}
}

func DbQueryRow(db *sql.DB, sqlStr string) *sql.Row {
	row := db.QueryRow(sqlStr)
	return row
	/*
		拿到row之后，可以scan从中获取对应的字段
		例如，获取row中的name、created字段
		var (
			name string
			created time.Time
		)
		row.Scan(&username, &created)
	*/
}

func DbQueryRows(db *sql.DB, sqlStr string) *sql.Rows {
	rows, err := db.Query(sqlStr)
	if err != nil {
		log.Println(err)
	}
	defer rows.Close()
	// If the database is being written to ensure to check for Close
	// errors that may be returned from the driver. The query may
	// encounter an auto-commit error and be forced to rollback changes.
	rerr := rows.Close()
	if rerr != nil {
		log.Println(err)
	}
	// Rows.Err will report the last error encountered by Rows.Scan.
	if err := rows.Err(); err != nil {
		log.Println(err)
	}
	return rows
	/*
		拿到rows之后，可以遍历rows，从中获取字段
		例如，获取所有rows中的name字段
			for rows.Next() {
				var name string
				if err := rows.Scan(&name); err != nil {
					// Check for a scan error.
					// Query rows will be closed with defer.
					log.Println(err)
				}
				names = append(names, name)
			}
	*/
}
